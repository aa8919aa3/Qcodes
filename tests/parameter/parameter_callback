import logging
import time
from collections.abc import Callable
from contextlib import contextmanager
from dataclasses import dataclass
from typing import Optional

import pytest

from qcodes.instrument_drivers.mock_instruments import DummyInstrument
from qcodes.parameters import Parameter, ParameterBase
from qcodes.utils.validators import Ints, Numbers

CallbackFunction = Callable[[ParameterBase, float], None]


@dataclass(frozen=True)
class _Constants:
    """Test constants centralized in a dataclass for better maintainability."""

    VALUE_DEFAULT: int = 42
    VALUE_INSTRUMENT: int = 23
    PERFORMANCE_ITERATIONS: int = 1000
    PERFORMANCE_MAX_OVERHEAD: float = 2.0


class _TestDataManager:
    """Class to manage test data and state."""

    def __init__(self) -> None:
        self._latest_value: float = 0
        self.callback_called: bool = False
        self.callback_count: int = 0

    @property
    def latest_value(self) -> float:
        return self._latest_value

    @latest_value.setter
    def latest_value(self, value: float) -> None:
        self._latest_value = value

    def reset(self) -> None:
        """Reset test data state."""
        self._latest_value = 0
        self.callback_called = False
        self.callback_count = 0


class ParameterTestHelper:
    """Helper class for parameter-related test operations."""

    def __init__(self) -> None:
        self.test_data = _TestDataManager()

    def create_parameter(self) -> Parameter:
        """Create a parameter with dummy get/set commands."""
        return Parameter(
            name="test_param",
            instrument=None,
            set_cmd=self._dummy_set,
            get_cmd=self._dummy_get,
        )

    def _dummy_set(self, value: float) -> None:
        self.test_data.latest_value = value

    def _dummy_get(self) -> float:
        return self.test_data.latest_value

    @contextmanager
    def parameter_context(self) -> Parameter:
        """Context manager for parameter cleanup."""
        param = self.create_parameter()
        try:
            yield param
        finally:
            ParameterBase._database_callback = None
            self.test_data.reset()


class TestParameterCallbacks:
    """Test suite for parameter database callbacks."""

    CONSTANTS = _Constants()

    @pytest.fixture
    def helper(self) -> ParameterTestHelper:
        """Fixture providing a test helper instance."""
        return ParameterTestHelper()

    @pytest.fixture
    def clean_parameter(self, helper: ParameterTestHelper) -> Parameter:
        """Fixture providing a clean parameter instance."""
        with helper.parameter_context() as param:
            yield param

    @pytest.fixture
    def dummy_instrument(self, helper: ParameterTestHelper) -> DummyInstrument:
        """Fixture providing a dummy instrument instance."""
        instrument = DummyInstrument("dummy")
        instrument.add_parameter(
            "test_param",
            parameter_class=Parameter,
            set_cmd=helper._dummy_set,
            get_cmd=helper._dummy_get,
        )
        try:
            yield instrument
        finally:
            instrument.close()

    def create_test_callback(
        self, test_data: _TestDataManager, expected_value: Optional[float] = None
    ) -> CallbackFunction:
        """Create a test callback function with validation."""

        def callback(param: ParameterBase, value: float) -> None:
            test_data.callback_called = True
            test_data.callback_count += 1
            assert param.name == "test_param", (
                f"Expected parameter name 'test_param', got {param.name}"
            )
            if expected_value is not None:
                assert value == expected_value, (
                    f"Expected value {expected_value}, got {value}"
                )

        return callback

    @pytest.mark.parametrize("test_value", [0, CONSTANTS.VALUE_DEFAULT, -1, 999])
    def test_callback_executes_with_correct_parameters(
        self, clean_parameter: Parameter, helper: ParameterTestHelper, test_value: float
    ) -> None:
        """Test callback execution with various parameter values."""
        ParameterBase._database_callback = self.create_test_callback(
            helper.test_data, test_value
        )
        clean_parameter(test_value)
        assert helper.test_data.callback_called, "Callback was not executed"

    def test_callback_with_instrument(
        self, dummy_instrument: DummyInstrument, helper: ParameterTestHelper
    ) -> None:
        """Test callback functionality with instrument parameters."""
        ParameterBase._database_callback = self.create_test_callback(
            helper.test_data,
            self.CONSTANTS.VALUE_INSTRUMENT,
        )
        param = dummy_instrument.parameters["test_param"]
        param(self.CONSTANTS.VALUE_INSTRUMENT)
        assert helper.test_data.callback_called, (
            "Instrument parameter callback was not executed"
        )

    def test_callback_error_handling(
        self, clean_parameter: Parameter, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test error handling in callback execution."""
        error_message = "Test error"

        def failing_callback(param: ParameterBase, value: float) -> None:
            raise RuntimeError(error_message)

        ParameterBase._database_callback = failing_callback

        with caplog.at_level(logging.ERROR):
            clean_parameter(self.CONSTANTS.VALUE_DEFAULT)
            assert "Exception while running parameter callback" in caplog.text
            assert error_message in caplog.text

    def test_callback_performance(
        self, clean_parameter: Parameter, helper: ParameterTestHelper
    ) -> None:
        """Test callback performance overhead."""

        def measure_execution_time(
            callback: Optional[CallbackFunction] = None,
        ) -> float:
            if callback:
                ParameterBase._database_callback = callback
            start_time = time.perf_counter()
            for _ in range(self.CONSTANTS.PERFORMANCE_ITERATIONS):
                clean_parameter(self.CONSTANTS.VALUE_DEFAULT)
            return time.perf_counter() - start_time

        base_time = measure_execution_time()
        assert base_time > 0, "Invalid negative base time measurement"

        callback_time = measure_execution_time(
            self.create_test_callback(helper.test_data)
        )
        assert callback_time > 0, "Invalid negative callback time measurement"
        assert callback_time < base_time * self.CONSTANTS.PERFORMANCE_MAX_OVERHEAD, (
            f"Callback overhead too high: {callback_time:.2f}s vs {base_time:.2f}s base time"
        )

    def test_callback_thread_safety(
        self, clean_parameter: Parameter, helper: ParameterTestHelper
    ) -> None:
        """Test thread safety of callback execution."""
        ParameterBase._database_callback = self.create_test_callback(helper.test_data)
        clean_parameter(self.CONSTANTS.VALUE_DEFAULT)
        assert helper.test_data.callback_count == 1, (
            f"Expected exactly one callback execution, got {helper.test_data.callback_count}"
        )

    def test_callback_none(self, clean_parameter: Parameter) -> None:
        """Test parameter behavior without callback."""
        ParameterBase._database_callback = None
        clean_parameter(self.CONSTANTS.VALUE_DEFAULT)
        assert clean_parameter() == self.CONSTANTS.VALUE_DEFAULT

    def test_callback_independence(self, clean_parameter: Parameter) -> None:
        """Test callback isolation between tests."""
        assert ParameterBase._database_callback is None, (
            "Database callback not properly reset from previous test"
        )

    def test_callback_multiple_parameters(self, helper: ParameterTestHelper) -> None:
        """Test callback behavior with multiple parameters."""
        param1 = helper.create_parameter()
        param2 = helper.create_parameter()

        ParameterBase._database_callback = self.create_test_callback(helper.test_data)

        param1(self.CONSTANTS.VALUE_DEFAULT)
        param2(self.CONSTANTS.VALUE_DEFAULT)

        assert helper.test_data.callback_count == 2, (
            "Callback should be called for each parameter"
        )

    def test_callback_value_persistence(self, clean_parameter: Parameter) -> None:
        """Test that callback doesn't interfere with parameter value persistence."""
        test_value = self.CONSTANTS.VALUE_DEFAULT

        def callback(param: ParameterBase, value: float) -> None:
            value += 1

        ParameterBase._database_callback = callback
        clean_parameter(test_value)

        assert clean_parameter() == test_value, (
            "Parameter value should remain unchanged"
        )

    def test_callback_with_different_parameter_types(
        self, helper: ParameterTestHelper
    ) -> None:
        """Test callback behavior with different parameter types."""
        int_param = Parameter(
            name="test_param_int",
            set_cmd=None,
            get_cmd=None,
            vals=Ints(),
        )
        float_param = Parameter(
            name="test_param_float",
            set_cmd=None,
            get_cmd=None,
            vals=Numbers(),
        )

        callback_values = []

        def type_checking_callback(param: ParameterBase, value: float) -> None:
            callback_values.append((param.name, type(value)))

        ParameterBase._database_callback = type_checking_callback

        int_param(42)
        float_param(42.5)

        assert len(callback_values) == 2, "Both callbacks should execute"
        assert callback_values[0][1] is int, "Integer parameter should pass int"
        assert callback_values[1][1] is float, "Float parameter should pass float"

    def test_callback_concurrent_updates(self, helper: ParameterTestHelper) -> None:
        """Test callback behavior with rapid parameter updates."""
        from concurrent.futures import ThreadPoolExecutor

        param = helper.create_parameter()
        update_count = 100

        def update_parameter(value: float) -> None:
            param(value)

        ParameterBase._database_callback = self.create_test_callback(helper.test_data)

        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = [
                executor.submit(update_parameter, i) for i in range(update_count)
            ]
            for future in futures:
                future.result()

        assert helper.test_data.callback_count == update_count, (
            f"Expected {update_count} callbacks, got {helper.test_data.callback_count}"
        )

    def test_callback_chaining(self, helper: ParameterTestHelper) -> None:
        """Test multiple callbacks can be chained together."""
        param = helper.create_parameter()
        callback_order = []

        def callback1(param: ParameterBase, value: float) -> None:
            callback_order.append(1)
            callback2(param, value)

        def callback2(param: ParameterBase, value: float) -> None:
            callback_order.append(2)

        ParameterBase._database_callback = callback1
        param(self.CONSTANTS.VALUE_DEFAULT)

        assert callback_order == [1, 2], "Callbacks should execute in order"

    def test_callback_memory_cleanup(self, helper: ParameterTestHelper) -> None:
        """Test that callbacks don't cause memory leaks."""
        import gc
        import weakref

        param = helper.create_parameter()

        def create_callback() -> CallbackFunction:
            local_data = [0]

            def callback(param: ParameterBase, value: float) -> None:
                local_data[0] = value

            return callback

        callback = create_callback()
        ref = weakref.ref(callback)
        ParameterBase._database_callback = callback

        param(self.CONSTANTS.VALUE_DEFAULT)

        ParameterBase._database_callback = None
        del callback
        gc.collect()

        assert ref() is None, "Callback should be garbage collected"

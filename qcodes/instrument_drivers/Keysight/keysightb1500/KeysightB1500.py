from __future__ import annotations
from typing import Dict
from qcodes import VisaInstrument, InstrumentChannel
from collections import defaultdict

from qcodes.instrument_drivers.Keysight.keysightb1500.constants import ChNr, SlotNr, InstrClass

from qcodes.instrument_drivers.Keysight.keysightb1500.message_builder import \
    MessageBuilder


class B1500Module(InstrumentChannel):
    INSTRUMENT_CLASS = None

    def __init__(self, parent: KeysightB1500, name: str, slot_nr, **kwargs):
        self.channels = []  # will be populated in the module subclasses because channel count is module specific
        self.slot_nr = SlotNr(slot_nr)

        if name is None:
            number = len(parent.by_class[self.INSTRUMENT_CLASS]) + 1
            name = self.INSTRUMENT_CLASS.lower() + str(number)
        super().__init__(parent=parent, name=name, **kwargs)

    @staticmethod
    def from_model_name(model: str, slot_nr: int, parent: KeysightB1500, name: str = None):
        """
        Creates the correct instance type for instrument by model name.

        :param model: Model name such as 'B1517A'
        :param slot_nr: Slot number of this module (not channel numeber)
        :param parent: Reference to B1500 mainframe instance
        :param name: If `None` (Default) then the name is autogenerated from the instrument class.
        :return:
        """
        if model == 'B1517A':
            return B1517A(slot_nr=slot_nr, parent=parent, name=name)
        elif model == 'B1520A':
            return B1520A(slot_nr=slot_nr, parent=parent, name=name)
        elif model == 'B1530A':
            return B1530A(slot_nr=slot_nr, parent=parent, name=name)
        else:
            raise NotImplementedError('Module type not yet supported.')


class B1517A(B1500Module):
    INSTRUMENT_CLASS = InstrClass.SMU

    def __init__(self, parent: KeysightB1500, name: str, slot_nr, **kwargs):
        super().__init__(parent, name, slot_nr, **kwargs)

        self.channels = (ChNr(slot_nr),)


class B1520A(B1500Module):
    INSTRUMENT_CLASS = InstrClass.CMU

    def __init__(self, parent: KeysightB1500, name: str, slot_nr, **kwargs):
        super().__init__(parent, name, slot_nr, **kwargs)

        self.channels = (ChNr(slot_nr),)


class B1530A(B1500Module):
    INSTRUMENT_CLASS = 'AUX'

    def __init__(self, parent: KeysightB1500, name: str, slot_nr, **kwargs):
        super().__init__(parent, name, slot_nr, **kwargs)

        self.channels = (ChNr(slot_nr), ChNr(int(f'{slot_nr:d}02')))


class KeysightB1500(VisaInstrument):
    def __init__(self, name, address, **kwargs):
        super().__init__(name, address, terminator='\r\n', **kwargs)

        self.by_slot = {}
        self.by_channel = {}
        self.by_class = defaultdict(list)

        self.mb = MessageBuilder() # Todo. Remove and use a MessageBuilder Factory instead(?)

        # TODO do a UNT query to determine Modules. generate a module object for
        # each found module.
        self._find_modules()

    def add_submodule(self, name: str, submodule: B1500Module):
        # TODO can we have typehint here that satisfies both the super().__init__ and restricts
        # submodules to be of type B1500Module?
        super().add_submodule(name, submodule)

        self.by_class[submodule.INSTRUMENT_CLASS].append(submodule)
        self.by_slot[submodule.slot_nr] = submodule
        for ch in submodule.channels:
            self.by_channel[ch] = submodule

    def reset(self):
        """Performs an instrument reset.

        Does not reset error queue!
        """
        self.write('*RST')

    def get_status(self):
        return self.ask('*STB?')

    # TODO: Data Output parser: At least for Format FMT1,0 and maybe for a
    # second (binary) format. 8 byte binary format would be nice because it
    # comes with time stamp
    # FMT1,0: ASCII (12 digits data with header) <CR/LF^EOI>

    def _find_modules(self):
        from qcodes.instrument_drivers.Keysight.keysightb1500.constants import UNT

        r = self.ask(MessageBuilder().unt_query(mode=UNT.Mode.MODULE_INFO_ONLY).message)

        slot_population = parse_module_query_response(r)

        for slot_nr, model in slot_population.items():
            module = B1500Module.from_model_name(model, slot_nr, self)

            self.add_submodule(name=module.short_name, submodule=module)


def parse_module_query_response(response: str) -> Dict[SlotNr, str]:
    """
    Extract installed module info from str and return it as a dict.

    :param response: Response str to `UNT? 0` query.
    :return: Dict[SlotNr: model_name_str]
    """
    import re
    pattern = r';?(?P<model>\w+),(?P<revision>\d+)'

    moduleinfo = re.findall(pattern, response)

    return {SlotNr(slot_nr): model for slot_nr, (model, rev) in enumerate(moduleinfo, start=1) if model != '0'}
